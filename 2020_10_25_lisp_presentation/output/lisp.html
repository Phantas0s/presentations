\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

\begin{frame}{WARNING}
\protect\hypertarget{warning}{}
\begin{itemize}
\tightlist
\item
  I make mistakes.

  \begin{itemize}
  \tightlist
  \item
    Sorry if I did!
  \end{itemize}
\item
  Feedback welcome.
\end{itemize}
\end{frame}

\begin{frame}{John McCarthy?}
\protect\hypertarget{john-mccarthy}{}
\begin{itemize}
\tightlist
\item
  Pioneer who contributed to AI, Internet, the web.
\item
  At MIT in the 60's.
\item
  ``He flew planes, climbed mountains, and traveled to the Soviet Union
  and China in the 1960s and 70s at a time when it was a major
  challenge.''
\end{itemize}
\end{frame}

\begin{frame}{A bit of Context}
\protect\hypertarget{a-bit-of-context}{}
\begin{itemize}
\tightlist
\item
  The part II of this paper has never been written.
\item
  Lisp and Fortran were written for the IBM 704 (available at MIT).

  \begin{itemize}
  \tightlist
  \item
    ``Only computer which can handle complex math'' - Wikipedia
  \end{itemize}
\item
  Second oldest high level programming language (non-assembly language).

  \begin{itemize}
  \tightlist
  \item
    Only Fortran older than Lisp.
  \end{itemize}
\item
  Today, Lisp is a family of languages

  \begin{itemize}
  \tightlist
  \item
    Many ``dialects''
  \item
    This paper is the foundation of all of these languages\ldots{} and
    more (JINGLE!).
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{IBM 704}
\protect\hypertarget{ibm-704}{}
\begin{figure}
\centering
\includegraphics{images/IBM_704.jpg}
\caption{The IBM 704}
\end{figure}
\end{frame}

\begin{frame}{Good Old Languages}
\protect\hypertarget{good-old-languages}{}
\begin{itemize}
\tightlist
\item
  IPL2 (1956) - List processing in Assembly.
\item
  Fortran (1957) - No list processing
\item
  Lisp (for LISt Processing) (1959-1962?)
\end{itemize}
\end{frame}

\begin{frame}{Why Lisp?}
\protect\hypertarget{why-lisp}{}
\begin{itemize}
\tightlist
\item
  AI (term coined by McCarthy)

  \begin{itemize}
  \tightlist
  \item
    They thought they were almost there in the 50s / 60s.
  \item
    McCarthy wrote a ``funny paper'' later ``HUMAN-LEVEL AI IS HARDER
    THAN IT SEEMED IN 1955''
  \item
    Chess player (beginning of CS game theory).
  \end{itemize}
\item
  ``Mathematical language''.
\item
  Programming the Advice Taker (proposed in 1958).
\end{itemize}
\end{frame}

\hypertarget{the-paper}{%
\section{The Paper}\label{the-paper}}

\begin{frame}{Advice Taker}
\protect\hypertarget{advice-taker}{}
\begin{quote}
``representing information about the world by sentences in a suitable
formal language and a reasoning program that would decide what to do by
making logical inferences. Representing sentences by list structure
seemed appropriate - it still is - and a list processing language also
seemed appropriate for programming the operations involved in deduction
- and still is.'' - McCarthy, 1979
\end{quote}

\begin{itemize}
\tightlist
\item
  From the paper: Lisp handle declarative and imperative sentences using
  lists.
\end{itemize}
\end{frame}

\begin{frame}[fragile]{The notation: S-Expression and M-expressions}
\protect\hypertarget{the-notation-s-expression-and-m-expressions}{}
\begin{block}{S-Expression (paper)}
\protect\hypertarget{s-expression-paper}{}
Characters: \texttt{(} \texttt{.} \texttt{)}

(CAR(CONS,x,y))\\
(CDR(CONS,x,y))
\end{block}

\begin{block}{M-Expression (paper, never implemented)}
\protect\hypertarget{m-expression-paper-never-implemented}{}
car {[}cons {[}x; y{]}{]} = x\\
cdr {[}cons {[}x; y{]}{]} = y
\end{block}

\begin{block}{Actual code (Scheme - dialect of Lisp)}
\protect\hypertarget{actual-code-scheme---dialect-of-lisp}{}
(car (cons x y))\\
(cdr (cons x y))
\end{block}
\end{frame}

\begin{frame}[fragile]{Functions}
\protect\hypertarget{functions}{}
\begin{itemize}
\tightlist
\item
  Functions first class citizen (code as data)
\item
  Precise that it's \textbf{not} the usual mathematics term
  ``function''.
\item
  Inspired by Church's lambda-notation (1936).

  \begin{itemize}
  \tightlist
  \item
    Turing Machine (1936) ``too complicated''.
  \end{itemize}
\item
  Use of lambda expression as bedrock for computation.
\item
  Function composition to create new function.
\end{itemize}

\begin{block}{Example (Scheme)}
\protect\hypertarget{example-scheme}{}
\begin{verbatim}
(+ 2 3)
(apply + '(1 2))
((lambda (x) (+ x x)) 2)
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]{Recursion}
\protect\hypertarget{recursion}{}
\begin{itemize}
\tightlist
\item
  Describe formalism for defining function recursively.
\item
  First programming language with recursion.
\end{itemize}

\begin{block}{Example (Scheme)}
\protect\hypertarget{example-scheme-1}{}
\begin{verbatim}
(define (factorial n)
    (if (= n 0)
        1
        (* n (factorial (- n 1))) ))
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]{Conditionals}
\protect\hypertarget{conditionals}{}
\begin{itemize}
\tightlist
\item
  First use of conditional expressions in a programming language.

  \begin{itemize}
  \tightlist
  \item
    Predicates: function returning \#T or \#F.
  \item
    Essential for testing recursive base cases.
  \end{itemize}
\item
  Fortran had IF but it was ``very awkward to use'' - McCarthy 1979.
\end{itemize}

\begin{block}{Example (Scheme)}
\protect\hypertarget{example-scheme-2}{}
\begin{verbatim}
(cond ((equal? x "#t") #t)
    ((equal? x "#f") #f)
    (else x))
\end{verbatim}
\end{block}
\end{frame}

\begin{frame}[fragile]{Linked List (basic data structure)}
\protect\hypertarget{linked-list-basic-data-structure}{}
\begin{block}{Modern Lisp (Scheme)}
\protect\hypertarget{modern-lisp-scheme}{}
\texttt{(car\ (cons\ x\ y))}~\\
\texttt{(cdr\ (cons\ x\ y))}
\end{block}

\begin{block}{Box and Pointer diagram}
\protect\hypertarget{box-and-pointer-diagram}{}
\texttt{(cons\ 42\ (cons\ 69\ (cons\ 613\ \textquotesingle{}()))}

\begin{figure}
\centering
\includegraphics{images/cons-cell.png}
\caption{Pointer diagram}
\end{figure}
\end{block}
\end{frame}

\begin{frame}[fragile]{???}
\protect\hypertarget{section}{}
\begin{itemize}
\tightlist
\item
  car? cdr? WAT???

  \begin{itemize}
  \tightlist
  \item
    Nice heritage from IBM 704 memory access.
  \end{itemize}
\end{itemize}

\texttt{caddr{[}x{]}\ for\ car{[}cdr{[}cdr{[}x{]}{]}}~\\
\texttt{(caddr\ x)\ for\ (car\ (cdr\ (cdr\ x))))}

\begin{itemize}
\tightlist
\item
  About functions which have not one letter
\end{itemize}

\begin{quote}
" \ldots{} is convenient to allow English words and phrases to stand for
atomic entities for mnemonic reasons" - John McCarthy (paper)
\end{quote}

\begin{itemize}
\tightlist
\item
  \ldots{} what about other programmers?
\end{itemize}
\end{frame}

\begin{frame}{Garbage collection}
\protect\hypertarget{garbage-collection}{}
\begin{quote}
"\ldots{} formerly pointed cannot be reached by a car âˆ’ cdr chain from
any base register. Such a register may be considered abandoned by the
program because its contents can no longer be found by any possible
program; hence its contents are no longer of interest, and so we would
like to have it back on the free-storage list. This comes about in the
following way. Nothing happens until the program runs out of free
storage. When a free register is wanted, and there is none left on the
free-storage list, a reclamation cycle starts.
\end{quote}
\end{frame}

\begin{frame}[fragile]{Apply and Eval}
\protect\hypertarget{apply-and-eval}{}
\begin{itemize}
\tightlist
\item
  ``Universal S-Function apply''

  \begin{itemize}
  \tightlist
  \item
    Universal turing machine
  \item
    \texttt{apply{[}f\ ;\ args{]}\ =\ eval{[}cons{[}f\ ;\ appq{[}args{]}{]};\ NIL{]},}
  \end{itemize}
\end{itemize}

\begin{quote}
``Writing eval required inventing a notation representing LISP functions
as LISP data, and such a notation was devised for the purposes of the
paper with no thought that it would be used to express LISP programs in
practice'' - McCarthy, 1979
\end{quote}
\end{frame}

\begin{frame}{Apply (Lisp Programmer's Manual 1.5)}
\protect\hypertarget{apply-lisp-programmers-manual-1.5}{}
\begin{figure}
\centering
\includegraphics{images/apply.png}
\caption{Apply}
\end{figure}
\end{frame}

\begin{frame}{Eval (Lisp Programmer's Manual 1.5)}
\protect\hypertarget{eval-lisp-programmers-manual-1.5}{}
\begin{figure}
\centering
\includegraphics{images/eval.png}
\caption{Eval}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Eval (Scheme)}
\protect\hypertarget{eval-scheme}{}
\begin{verbatim}
(define (eval exp env)
  (cond ((self-evaluating? exp) exp)
        ((variable? exp) (lookup-variable-value exp env))
        ((quoted? exp) (text-of-quotation exp))
        ((assignment? exp) (eval-assignment exp env))
        ((definition? exp) (eval-definition exp env))
        ((if? exp) (eval-if exp env))
        ((lambda? exp)
         (make-procedure (lambda-parameters exp)
                         (lambda-body exp)
                         env))
        ((begin? exp) 
         (eval-sequence (begin-actions exp) env))
        ((cond? exp) (eval (cond->if exp) env))
        ((application? exp)
         (apply (eval (operator exp) env)
                (list-of-values (operands exp) env)))
        (else
         (error "Unknown expression type -- EVAL" exp))))
\end{verbatim}
\end{frame}

\begin{frame}[fragile]{Apply (Scheme)}
\protect\hypertarget{apply-scheme}{}
\begin{verbatim}
(define (apply procedure arguments)
  (cond ((primitive-procedure? procedure)
         (apply-primitive-procedure procedure arguments))
        ((compound-procedure? procedure)
         (eval-sequence
           (procedure-body procedure)
           (extend-environment
             (procedure-parameters procedure)
             arguments
             (procedure-environment procedure))))
        (else
         (error
          "Unknown procedure type -- APPLY" procedure))))
\end{verbatim}
\end{frame}

\hypertarget{legacy}{%
\section{Legacy}\label{legacy}}

\begin{frame}{The most important}
\protect\hypertarget{the-most-important}{}
\begin{itemize}
\tightlist
\item
  Everything we saw before (recursion, conditionals, lambdas\ldots)

  \begin{itemize}
  \tightlist
  \item
    Lambdas implemented in most mainstream programming languages
  \end{itemize}
\item
  First functional programming language
\item
  Smalltalk (70s) was very influenced by Lisp (today: Pharo)

  \begin{itemize}
  \tightlist
  \item
    One of the first OOP language
  \item
    One rule ``almost everything is function'' was appealing to Alan
    Kay.

    \begin{itemize}
    \tightlist
    \item
      In smalltalk, everything is an object
    \end{itemize}
  \item
    Garbage collection
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Lisp today}
\protect\hypertarget{lisp-today}{}
\begin{itemize}
\tightlist
\item
  Clojure
\item
  Common Lisp
\item
  Emacs Lisp
\item
  Scheme
\end{itemize}
\end{frame}

\begin{frame}{xkcd}
\protect\hypertarget{xkcd}{}
\begin{figure}
\centering
\includegraphics{https://imgs.xkcd.com/comics/lisp_cycles.png}
\caption{Parentheses?}
\end{figure}
\end{frame}

\begin{frame}{References}
\protect\hypertarget{references}{}
\begin{itemize}
\tightlist
\item
  \href{https://github.com/Phantas0s/presentations/}{Slides -
  https://github.com/Phantas0s/presentations/}
\item
  \href{http://www-formal.stanford.edu/jmc/slides/wrong/wrong-sli/wrong-sli.html}{HUMAN-LEVEL
  AI IS HARDER THAN IT SEEMED IN 1955}
\item
  \href{http://jmc.stanford.edu/articles/lisp/lisp.pdf}{History of Lisp}
\item
  \href{http://jmc.stanford.edu/}{Page on John McCarty (all papers)}
\end{itemize}
\end{frame}
